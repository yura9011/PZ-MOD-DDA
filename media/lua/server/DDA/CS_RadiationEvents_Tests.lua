-- DDA Radiation Events Property Tests
-- Property-based tests for the Radiation Event Manager
-- Run via debug console: CS_RadiationEvents_Tests.runAll()

local CS_RadiationEvents_Tests = {}

-- Load dependencies
local CS_Config = require("DDA/CS_Config")
local CS_RadiationEvents = require("DDA/CS_RadiationEvents")

-- ============================================================================
-- TEST FRAMEWORK (Simple PBT Implementation)
-- ============================================================================

local TestResults = {
    passed = 0,
    failed = 0,
    errors = {}
}

local function resetResults()
    TestResults.passed = 0
    TestResults.failed = 0
    TestResults.errors = {}
end

local function recordPass(testName)
    TestResults.passed = TestResults.passed + 1
    print("[PASS] " .. testName)
end

local function recordFail(testName, message, example)
    TestResults.failed = TestResults.failed + 1
    local errorInfo = {
        test = testName,
        message = message,
        example = example
    }
    table.insert(TestResults.errors, errorInfo)
    print("[FAIL] " .. testName .. ": " .. message)
    if example then
        print("       Failing example: " .. tostring(example))
    end
end

-- ============================================================================
-- MOCK MODDATA FOR TESTING
-- ============================================================================

local mockModData = {}

--- Reset mock ModData to clean state
local function resetMockModData()
    mockModData = {}
end

--- Override ModData.getOrCreate for testing
local originalGetOrCreate = nil

local function setupMockModData()
    if not originalGetOrCreate then
        originalGetOrCreate = ModData.getOrCreate
    end
    ModData.getOrCreate = function(key)
        mockModData[key] = mockModData[key] or {}
        return mockModData[key]
    end
end

local function teardownMockModData()
    if originalGetOrCreate then
        ModData.getOrCreate = originalGetOrCreate
    end
end

-- ============================================================================
-- MOCK PLAYER GENERATOR
-- ============================================================================

--- Generate a mock player for testing radiation effects
--- @param isIndoors boolean Whether player is indoors
--- @param hasHazmat boolean Whether player has hazmat suit
--- @return table mockPlayer A mock player object
local function generateMockPlayer(isIndoors, hasHazmat)
    local mockStats = {
        _stress = 0,
        _panic = 0,
        getStress = function(self) return self._stress end,
        setStress = function(self, val) self._stress = val end,
        getPanic = function(self) return self._panic end,
        setPanic = function(self, val) self._panic = val end
    }
    
    local mockBodyDamage = {
        _health = 100,
        getOverallBodyHealth = function(self) return self._health end,
        setOverallBodyHealth = function(self, val) self._health = val end
    }
    
    local mockRoom = isIndoors and {} or nil
    
    local mockSquare = {
        getRoom = function() return mockRoom end
    }
    
    local mockPlayer = {
        _isIndoors = isIndoors,
        _hasHazmat = hasHazmat,
        _stats = mockStats,
        _bodyDamage = mockBodyDamage,
        _square = mockSquare,
        getCurrentSquare = function(self) return self._square end,
        getStats = function(self) return self._stats end,
        getBodyDamage = function(self) return self._bodyDamage end,
        getWornItem = function(self, location)
            if self._hasHazmat and location == "FullSuit" then
                return {
                    getFullType = function() return "DDA.HazmatSuit" end
                }
            end
            return nil
        end
    }
    
    return mockPlayer
end

-- ============================================================================
-- PROPERTY 1: Radiation Type Validity
-- **Feature: DDA-expansion, Property 1: Radiation Type Validity**
-- **Validates: Requirements 1.1**
--
-- *For any* radiation event generated by the system, the type SHALL be one of 
-- exactly three valid values: "green", "violet", or "red".
-- ============================================================================

function CS_RadiationEvents_Tests.property1_RadiationTypeValidity()
    local testName = "Property 1: Radiation Type Validity"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    -- Valid types set
    local validTypes = {green = true, violet = true, red = true}
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Pick a random event type using the system's method
        local eventType = CS_RadiationEvents.pickRandomEvent()
        
        -- Verify the type is valid
        if not validTypes[eventType] then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, eventType='%s' is not a valid type (expected green, violet, or red)",
                i, tostring(eventType)
            )
            break
        end
        
        -- Also test isValidType function
        if not CS_RadiationEvents.isValidType(eventType) then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, isValidType('%s') returned false for valid type",
                i, tostring(eventType)
            )
            break
        end
        
        -- Test that startEvent only accepts valid types
        local success = CS_RadiationEvents.startEvent(eventType)
        local state = CS_RadiationEvents.getState()
        
        if state.active and not validTypes[state.type] then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, startEvent set invalid type='%s'",
                i, tostring(state.type)
            )
            break
        end
        
        -- Clean up
        CS_RadiationEvents.endEvent()
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Invalid radiation type generated", failingExample)
    end
    
    return allPassed, failingExample
end

--- Test that isValidType correctly rejects invalid types
function CS_RadiationEvents_Tests.property1_InvalidTypeRejection()
    local testName = "Property 1b: Invalid Type Rejection"
    local allPassed = true
    local failingExample = nil
    
    -- Test invalid types
    local invalidTypes = {
        nil, "", "blue", "yellow", "GREEN", "Violet", "RED",
        123, true, false, {}, "radiation", "none"
    }
    
    for _, invalidType in ipairs(invalidTypes) do
        if CS_RadiationEvents.isValidType(invalidType) then
            allPassed = false
            failingExample = string.format(
                "isValidType('%s') returned true for invalid type",
                tostring(invalidType)
            )
            break
        end
    end
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Invalid type was accepted", failingExample)
    end
    
    return allPassed, failingExample
end

-- ============================================================================
-- PROPERTY 2: No Consecutive Same Radiation Type
-- **Feature: DDA-expansion, Property 2: No Consecutive Same Radiation Type**
-- **Validates: Requirements 1.2**
--
-- *For any* sequence of two consecutive radiation events, the second event's 
-- type SHALL differ from the first event's type.
-- ============================================================================

function CS_RadiationEvents_Tests.property2_NoConsecutiveSameType()
    local testName = "Property 2: No Consecutive Same Radiation Type"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Start with a random last type
        local state = CS_RadiationEvents.getState()
        local validTypes = CS_RadiationEvents.VALID_TYPES
        local lastType = validTypes[ZombRand(#validTypes) + 1]
        state.lastType = lastType
        
        -- Pick next event type
        local nextType = CS_RadiationEvents.pickRandomEvent()
        
        -- Verify next type is different from last type
        if nextType == lastType then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, lastType='%s', nextType='%s' (should be different)",
                i, tostring(lastType), tostring(nextType)
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Consecutive same radiation type selected", failingExample)
    end
    
    return allPassed, failingExample
end

--- Test consecutive events through startEvent/endEvent cycle
function CS_RadiationEvents_Tests.property2_ConsecutiveEventsCycle()
    local testName = "Property 2b: Consecutive Events Through Full Cycle"
    local iterations = 50
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    resetMockModData()
    
    local previousType = nil
    
    for i = 1, iterations do
        -- Pick and start a new event
        local eventType = CS_RadiationEvents.pickRandomEvent()
        CS_RadiationEvents.startEvent(eventType)
        
        local state = CS_RadiationEvents.getState()
        local currentType = state.type
        
        -- After first iteration, verify no consecutive same type
        if previousType ~= nil and currentType == previousType then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, previousType='%s', currentType='%s' (consecutive same type)",
                i, tostring(previousType), tostring(currentType)
            )
            break
        end
        
        previousType = currentType
        
        -- End the event to prepare for next
        CS_RadiationEvents.endEvent()
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Consecutive same type in event cycle", failingExample)
    end
    
    return allPassed, failingExample
end

-- ============================================================================
-- PROPERTY 3: Duration Within Bounds
-- **Feature: DDA-expansion, Property 3: Duration Within Bounds**
-- **Validates: Requirements 1.3**
--
-- *For any* radiation event, the duration SHALL be between 30 and 120 minutes 
-- of in-game time (inclusive).
-- ============================================================================

function CS_RadiationEvents_Tests.property3_DurationWithinBounds()
    local testName = "Property 3: Duration Within Bounds"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    local minDuration = CS_Config.Radiation.minDuration  -- 30
    local maxDuration = CS_Config.Radiation.maxDuration  -- 120
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Pick a random event type and start event
        local eventType = CS_RadiationEvents.pickRandomEvent()
        CS_RadiationEvents.startEvent(eventType)
        
        -- Get the duration from state
        local state = CS_RadiationEvents.getState()
        local duration = state.duration
        
        -- Verify duration is within bounds
        if duration < minDuration then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, duration=%d is below minimum %d",
                i, duration, minDuration
            )
            break
        end
        
        if duration > maxDuration then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, duration=%d is above maximum %d",
                i, duration, maxDuration
            )
            break
        end
        
        -- Clean up
        CS_RadiationEvents.endEvent()
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Duration outside valid bounds", failingExample)
    end
    
    return allPassed, failingExample
end

--- Test that duration covers the full range (statistical test)
function CS_RadiationEvents_Tests.property3_DurationDistribution()
    local testName = "Property 3b: Duration Distribution Coverage"
    local iterations = 200
    local allPassed = true
    local failingExample = nil
    
    local minDuration = CS_Config.Radiation.minDuration  -- 30
    local maxDuration = CS_Config.Radiation.maxDuration  -- 120
    
    -- Track which durations we've seen
    local seenMin = false
    local seenMax = false
    local seenMid = false
    local midPoint = math.floor((minDuration + maxDuration) / 2)
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        local eventType = CS_RadiationEvents.pickRandomEvent()
        CS_RadiationEvents.startEvent(eventType)
        
        local state = CS_RadiationEvents.getState()
        local duration = state.duration
        
        -- Track distribution
        if duration == minDuration then seenMin = true end
        if duration == maxDuration then seenMax = true end
        if duration >= midPoint - 5 and duration <= midPoint + 5 then seenMid = true end
        
        CS_RadiationEvents.endEvent()
    end
    
    teardownMockModData()
    
    -- We should see values across the range (statistical check)
    -- Note: This is a probabilistic test, may occasionally fail
    if not seenMin and not seenMax and not seenMid then
        allPassed = false
        failingExample = string.format(
            "After %d iterations, distribution seems too narrow (min=%s, max=%s, mid=%s)",
            iterations, tostring(seenMin), tostring(seenMax), tostring(seenMid)
        )
    end
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Duration distribution too narrow", failingExample)
    end
    
    return allPassed, failingExample
end

-- ============================================================================
-- PROPERTY 4: Inactive Radiation Means No Effects
-- **Feature: DDA-expansion, Property 4: Inactive Radiation Means No Effects**
-- **Validates: Requirements 1.5**
--
-- *For any* player when radiation is inactive (active=false), the radiation 
-- damage applied SHALL be zero and no radiation-specific effects SHALL be triggered.
-- ============================================================================

function CS_RadiationEvents_Tests.property4_InactiveRadiationNoEffects()
    local testName = "Property 4: Inactive Radiation Means No Effects"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Ensure radiation is inactive
        local state = CS_RadiationEvents.getState()
        state.active = false
        state.type = nil
        
        -- Generate random player state
        local isIndoors = ZombRand(2) == 1
        local hasHazmat = ZombRand(2) == 1
        local mockPlayer = generateMockPlayer(isIndoors, hasHazmat)
        
        -- Record initial stats
        local initialStress = mockPlayer:getStats():getStress()
        local initialPanic = mockPlayer:getStats():getPanic()
        local initialHealth = mockPlayer:getBodyDamage():getOverallBodyHealth()
        
        -- Apply effects (should do nothing when inactive)
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        -- Verify no changes occurred
        local finalStress = mockPlayer:getStats():getStress()
        local finalPanic = mockPlayer:getStats():getPanic()
        local finalHealth = mockPlayer:getBodyDamage():getOverallBodyHealth()
        
        if finalStress ~= initialStress then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, stress changed from %f to %f when radiation inactive",
                i, initialStress, finalStress
            )
            break
        end
        
        if finalPanic ~= initialPanic then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, panic changed from %f to %f when radiation inactive",
                i, initialPanic, finalPanic
            )
            break
        end
        
        if finalHealth ~= initialHealth then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, health changed from %f to %f when radiation inactive",
                i, initialHealth, finalHealth
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Effects applied when radiation inactive", failingExample)
    end
    
    return allPassed, failingExample
end

--- Test that isActive returns false when radiation is not active
function CS_RadiationEvents_Tests.property4_IsActiveReturnsFalse()
    local testName = "Property 4b: isActive Returns False When Inactive"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Ensure radiation is inactive
        local state = CS_RadiationEvents.getState()
        state.active = false
        
        -- Verify isActive returns false
        if CS_RadiationEvents.isActive() then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, isActive() returned true when state.active=false",
                i
            )
            break
        end
        
        -- Verify getCurrentType returns nil
        local currentType = CS_RadiationEvents.getCurrentType()
        if currentType ~= nil then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, getCurrentType() returned '%s' when inactive",
                i, tostring(currentType)
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Incorrect active state reporting", failingExample)
    end
    
    return allPassed, failingExample
end

-- ============================================================================
-- PROPERTY 11: Radiation Effects Match Type
-- **Feature: DDA-expansion, Property 11: Radiation Effects Match Type**
-- **Validates: Requirements 4.1, 4.2, 4.3**
--
-- *For any* radiation exposure:
-- - Green radiation SHALL increase stress and apply slow damage
-- - Violet radiation SHALL increase panic
-- - Red radiation SHALL apply fast damage
-- ============================================================================

function CS_RadiationEvents_Tests.property11_GreenRadiationEffects()
    local testName = "Property 11a: Green Radiation Increases Stress and Applies Damage"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Set up active green radiation
        local state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "green"
        
        -- Generate unprotected outdoor player (0% protection)
        local mockPlayer = generateMockPlayer(false, false)
        
        -- Set initial values
        local initialStress = ZombRand(50) / 100  -- Random 0-0.5
        local initialHealth = 50 + ZombRand(50)   -- Random 50-100
        mockPlayer:getStats()._stress = initialStress
        mockPlayer:getBodyDamage()._health = initialHealth
        
        -- Apply effects
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        -- Verify stress increased
        local finalStress = mockPlayer:getStats():getStress()
        if finalStress <= initialStress then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, green radiation did not increase stress (initial=%f, final=%f)",
                i, initialStress, finalStress
            )
            break
        end
        
        -- Verify health decreased (damage applied)
        local finalHealth = mockPlayer:getBodyDamage():getOverallBodyHealth()
        if finalHealth >= initialHealth then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, green radiation did not apply damage (initial=%f, final=%f)",
                i, initialHealth, finalHealth
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Green radiation effects incorrect", failingExample)
    end
    
    return allPassed, failingExample
end

function CS_RadiationEvents_Tests.property11_VioletRadiationEffects()
    local testName = "Property 11b: Violet Radiation Increases Panic"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Set up active violet radiation
        local state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "violet"
        
        -- Generate unprotected outdoor player (0% protection)
        local mockPlayer = generateMockPlayer(false, false)
        
        -- Set initial panic value
        local initialPanic = ZombRand(50)  -- Random 0-50
        mockPlayer:getStats()._panic = initialPanic
        
        -- Apply effects
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        -- Verify panic increased
        local finalPanic = mockPlayer:getStats():getPanic()
        if finalPanic <= initialPanic then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, violet radiation did not increase panic (initial=%f, final=%f)",
                i, initialPanic, finalPanic
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Violet radiation effects incorrect", failingExample)
    end
    
    return allPassed, failingExample
end

function CS_RadiationEvents_Tests.property11_RedRadiationEffects()
    local testName = "Property 11c: Red Radiation Applies Fast Damage"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Set up active red radiation
        local state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "red"
        
        -- Generate unprotected outdoor player (0% protection)
        local mockPlayer = generateMockPlayer(false, false)
        
        -- Set initial health value
        local initialHealth = 50 + ZombRand(50)  -- Random 50-100
        mockPlayer:getBodyDamage()._health = initialHealth
        
        -- Apply effects
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        -- Verify health decreased (damage applied)
        local finalHealth = mockPlayer:getBodyDamage():getOverallBodyHealth()
        if finalHealth >= initialHealth then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, red radiation did not apply damage (initial=%f, final=%f)",
                i, initialHealth, finalHealth
            )
            break
        end
        
        -- Verify red damage is faster than green damage
        -- Red damagePerTick = 2.0, Green damagePerTick = 0.5
        local greenConfig = CS_Config.Radiation.types.green
        local redConfig = CS_Config.Radiation.types.red
        if redConfig.damagePerTick <= greenConfig.damagePerTick then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, red damage (%f) should be faster than green damage (%f)",
                i, redConfig.damagePerTick, greenConfig.damagePerTick
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Red radiation effects incorrect", failingExample)
    end
    
    return allPassed, failingExample
end

--- Test that each radiation type applies its specific effects and not others
function CS_RadiationEvents_Tests.property11_EffectsAreTypeSpecific()
    local testName = "Property 11d: Effects Are Type-Specific"
    local iterations = 100
    local allPassed = true
    local failingExample = nil
    
    setupMockModData()
    
    for i = 1, iterations do
        resetMockModData()
        
        -- Test green radiation doesn't increase panic
        local state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "green"
        
        local mockPlayer = generateMockPlayer(false, false)
        local initialPanic = 10
        mockPlayer:getStats()._panic = initialPanic
        
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        local finalPanic = mockPlayer:getStats():getPanic()
        if finalPanic ~= initialPanic then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, green radiation should not affect panic (initial=%f, final=%f)",
                i, initialPanic, finalPanic
            )
            break
        end
        
        -- Test violet radiation doesn't apply damage
        resetMockModData()
        state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "violet"
        
        mockPlayer = generateMockPlayer(false, false)
        local initialHealth = 100
        mockPlayer:getBodyDamage()._health = initialHealth
        
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        local finalHealth = mockPlayer:getBodyDamage():getOverallBodyHealth()
        if finalHealth ~= initialHealth then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, violet radiation should not apply damage (initial=%f, final=%f)",
                i, initialHealth, finalHealth
            )
            break
        end
        
        -- Test red radiation doesn't increase stress
        resetMockModData()
        state = CS_RadiationEvents.getState()
        state.active = true
        state.type = "red"
        
        mockPlayer = generateMockPlayer(false, false)
        local initialStress = 0.1
        mockPlayer:getStats()._stress = initialStress
        
        CS_RadiationEvents.applyEffects(mockPlayer)
        
        local finalStress = mockPlayer:getStats():getStress()
        if finalStress ~= initialStress then
            allPassed = false
            failingExample = string.format(
                "iteration=%d, red radiation should not affect stress (initial=%f, final=%f)",
                i, initialStress, finalStress
            )
            break
        end
    end
    
    teardownMockModData()
    
    if allPassed then
        recordPass(testName)
    else
        recordFail(testName, "Effects not type-specific", failingExample)
    end
    
    return allPassed, failingExample
end

-- ============================================================================
-- TEST RUNNER
-- ============================================================================

function CS_RadiationEvents_Tests.runAll()
    print("========================================")
    print("DDA Radiation Events Property Tests")
    print("========================================")
    
    resetResults()
    
    -- Run Property 1 tests
    CS_RadiationEvents_Tests.property1_RadiationTypeValidity()
    CS_RadiationEvents_Tests.property1_InvalidTypeRejection()
    
    -- Run Property 2 tests
    CS_RadiationEvents_Tests.property2_NoConsecutiveSameType()
    CS_RadiationEvents_Tests.property2_ConsecutiveEventsCycle()
    
    -- Run Property 3 tests
    CS_RadiationEvents_Tests.property3_DurationWithinBounds()
    CS_RadiationEvents_Tests.property3_DurationDistribution()
    
    -- Run Property 4 tests
    CS_RadiationEvents_Tests.property4_InactiveRadiationNoEffects()
    CS_RadiationEvents_Tests.property4_IsActiveReturnsFalse()
    
    -- Run Property 11 tests (Radiation Effects Match Type)
    CS_RadiationEvents_Tests.property11_GreenRadiationEffects()
    CS_RadiationEvents_Tests.property11_VioletRadiationEffects()
    CS_RadiationEvents_Tests.property11_RedRadiationEffects()
    CS_RadiationEvents_Tests.property11_EffectsAreTypeSpecific()
    
    -- Print summary
    print("========================================")
    print(string.format("Results: %d passed, %d failed", 
        TestResults.passed, TestResults.failed))
    print("========================================")
    
    if TestResults.failed > 0 then
        print("Failing tests:")
        for _, err in ipairs(TestResults.errors) do
            print("  - " .. err.test)
            print("    " .. err.message)
            if err.example then
                print("    Example: " .. err.example)
            end
        end
    end
    
    return TestResults
end

--- Run only Property 11 tests (Radiation Effects Match Type)
function CS_RadiationEvents_Tests.runProperty11()
    print("========================================")
    print("Property 11: Radiation Effects Match Type")
    print("**Validates: Requirements 4.1, 4.2, 4.3**")
    print("========================================")
    
    resetResults()
    
    CS_RadiationEvents_Tests.property11_GreenRadiationEffects()
    CS_RadiationEvents_Tests.property11_VioletRadiationEffects()
    CS_RadiationEvents_Tests.property11_RedRadiationEffects()
    CS_RadiationEvents_Tests.property11_EffectsAreTypeSpecific()
    
    print("========================================")
    print(string.format("Results: %d passed, %d failed", 
        TestResults.passed, TestResults.failed))
    print("========================================")
    
    if TestResults.failed > 0 then
        print("Failing tests:")
        for _, err in ipairs(TestResults.errors) do
            print("  - " .. err.test)
            print("    " .. err.message)
            if err.example then
                print("    Example: " .. err.example)
            end
        end
    end
    
    return TestResults
end

-- Export for debug console access
_G.CS_RadiationEvents_Tests = CS_RadiationEvents_Tests

return CS_RadiationEvents_Tests
